# MixChannel におけるレコメンドシステムの構築

以下では、時系列に合わせて過程を説明する。
だらだらと書き下す形になって申し訳ないので、重要だと考えている点は**強調**して表示することにする。
とはいえ、可能であれば全部読んでいただけるとありがたい。

所要期間:

- ユーザ推薦の実装: 2 ～ 3 ヶ月
- 動画推薦の実装: 1 ヶ月
- ライブ推薦の実装: 1.5 ヶ月

## 背景

MixChannel のユーザ多様化に対応するため、**推薦システムの構築**を行うことになった。
当時の私は新卒で入ってすぐで、**右も左もわからない中で MySQL と Google BigQuery のアクセス権が与えられた状態**。
メンターはいたが、DB の様子を質問できる程度でほとんど放置されている状態に近く、ほぼ独力で対応する必要があった。

## 技術検討

大学の情報システムの講義で協調フィルタリングやコンテンツベースドフィルタリングの基礎は理解していたが、座学的な情報を得るために**recsysdoc という有名なテキスト**を読むことにした。
そのほかに下調べを行うと、昨今の（協調）レコメンドアルゴリズムとして一般的なものとして、**行列分解（NMF）と Word2Vec**があることがわかった。
深層学習を用いた方法や、属性情報を混ぜて行う方法もあったが、実装が簡単な方法から考えていくことにした。

まずは**NMF を用いた手法**を適用した。
MixChannel には「ファン」といういわゆる follow に相当する機能があったので、この関係を行列化し、NMF による分解を行う。
ここで、過去 2 ヶ月のファン関係を用いて行列を作ったが、これは MySQL が非常に多くのデータを取得する必要があり、その対応に追われた。
結局、少しずつ取得するプログラムを書くという形に落ち着いた。
Python における NMF の実装はすでにいくつかあったが、**scikit-learn に乗っているものが高速で扱いやすかった**。
**NMF で得られた特徴ベクトルの良し悪しを判定**するために、**k-means**を用いてクラスタリングを行って内容を確認した。
自力で確認するには心許なかったので、MixChannel 文化に詳しいプロダクト側の人たちにも協力をいただいた。
確かに明らかに異なるクラスタが生成されているようだったので、NMF を用いた方法は使えるということが判断できた。
とはいえ、「人気ユーザクラスタ」という概念ができてしまっていた。
これは人気ユーザは多くの人からファン登録され、傾向が掴みつらいからではないかと考えた。
しかし、**事前に分解前の行列を動画投稿側のユーザについて正規化する**ことによって、その問題は解決した。

## ユーザ推薦の実装

まずは影響範囲の少ないところで実装してみようということで、検索画面にユーザを推薦するようなビューを作ることにした。
しかしクライアントの工数が足りていなかったため、**iOS 側のビュー**を自作し、それで様子を見ることにした。
Swift を触るのは初めてで、ネット上にはバージョン違いの情報が散乱していたが、1 週間ほどで作ることができた。

サーバ側はシンプルに flask を用いて実装した。
DAU が多すぎて、オンライン学習は現実的ではなかったので、**定時に行列分解を行い、データを出力し読み込み直すという処理**でデータの更新を実現した。
**作成したサーバ側コードは AWS EC2 にデプロイし、nginx でリバースプロキシ、supervisord でデーモン化を行った。**

このころはまだ AB テスト基盤を作ることができていなかったが、テストによって次のような事実がわかった。

- NMF で得られた類似度が高いほどタップされやすい
- ファン数が多いほど出やすいという補正をかけても、タップされやすくはならない
- NMF で得られたユーザ側ベクトルを用いるのではなく、最近 5 人とか 10 人のファン登録したユーザのベクトルを用いてユーザ側ベクトルを作ったほうがよい
- NMF で得られた推薦結果に、2 割程度推薦とは関係ないものを混ぜても全体のタップ数はあまり変化しない。ただし、違うものがタップされるのではなく、比較対象があることで推薦結果がよりタップされやすくなる。

## 動画推薦の実装

つぎに、動画を推薦する機能の実装をすることを考えた。
ユーザ推薦に比べて非推薦アイテム数が非常に多く、**NMF では現実的な時間で計算することができないという問題に直面した。**
ここで、冒頭で考慮した**Word2Vec**を用いることにした。
Word2Vec は自然言語処理のアルゴリズムであるが、アイテムを単語、特定のユーザのフォローしたアイテム列を文章と考えることによって、アイテムのベクトル表現を求めることができる。
ただし、似ているようでも fasttet は単語の文字表現が似ている単語を近くするようなアルゴリズムが入っているので、使用すると id が似たアイテムが近くなってしまうから注意が必要である。

Word2Vec の実装は gensim のものを用いることにした。
多少パラメータ調整を行ったのち、ユーザ推薦のものをもとにサーバ側実装を作成した。
クライアント側の実装は、クライアントサイドの人の手が空いていたので任せることにした。

この Word2Vec の実装による動画推薦は、とてもタップ率が良かった。
1 回のロードで 4 つの動画を表示するのだが、**ロード回数の 7 割程度動画推薦結果のタップ回数があり**、多くのユーザは動画推薦を見るために検索画面を表示しているという状態だった。

技術検討の開始からここまでで、およそ 3 ヶ月程度の月日が経過していた。

## ライブ推薦の実装

動画推薦の実装から半年以上間が空いて、今度はライブ推薦を作ることになった。
ただし、今回は新規ユーザに対して年齢・性別情報をもとに推薦するなど、今までとは異なるオーダーも含んでいた。

まず、年齢・性別推薦が本当に可能かどうかを検討した。
ライブにおいてアイテムを投げる（showroom や 17 などでもある概念で、投げ銭のことである）というイベントを評価として、Word2Vec でライブ配信者のベクトルを作った。
その後、視聴者側のベクトルを過去にアイテムを投げたライブ配信者のベクトルの算術平均として求めた。
さらに、年齢・性別のベクトルをその年齢・性別の視聴者のベクトルの算術平均として求めた。
この年齢・性別ベクトルを**t-SNE によって次元削減**し、二次元平面上にプロットした。
その結果、年齢・性別によって嗜好が変化していく様子が見て取れたので、年齢・性別による推薦はある程度効果があることがわかった。

ここまで得られた情報から、サーバ側開発を開始した。
前回の実装から間が空いていたため、**TypeHinting**等を用いてコード品質を重視しながら新たにコードを書くことにした。
**mypy による静的解析**が可能になり、実行時まで発見させないエラーが大幅に減少した。
また、構成としても、Golang ですでに書かれている MixChannel の API サーバに**gRPC**を用いてサーバ間通信を行い、推薦結果を送ることにした。
これによって、**Golang 側では型付きを前提としてコーディングが可能に**なったほか、**Protocol Buffers の proto ファイルによって通信仕様の確認**が簡単になった。
応答時間のチューニングも行い、DB 通信がボトルネックであるものの、それ以外の部分では 1ms を切るような時間での応答が可能になった。
また、推薦の計算の重い負荷に耐えるため、gRPC のクライアントロードバランサを用いた。

さらに、簡単に AB テストができるような基盤を設置し、細かな改良が容易に行えるようになった。
KPI をホーム画面におけるライブタップ回数とし、以下のような改善を行った。

- 推薦（+30%）
- 来場者数による補正(+15%)
- リアルタイムアイテム投げに対応(+10%)

この推薦にかかわる改善だけで、**タップ回数を約 65%増加**させることができた。

## その後

現在では動画推薦もコード構成、gRPC の利用という点でライブ推薦と同様になっている。
検索画面でのみ表示していた動画推薦が、動画画面トップに表示されるようになり、**動画視聴回数+15%**という成果が出た。
今後もさらなる改善が期待される。
